Golang: Не взаимодействуй через общую память, обращайся к памяти через взаимодействие

Так я перевел высокоуровневую концепцию синхронизации доступа к общим ресурсам, представленную разработчиками языка Go "Do not communicate by sharing memory; instead, share memory by communicating".

Для наглядности можно представить себе это через следующую аналогию: представим что у нас есть дисковый файл, куда хотят писать сразу куча процессов. Для синхронизации доступа мы можем использовать системный мьютекс. Кто успел залокать, тот и пишет, все остальные ждут. Либо, обращаясь к представленному концепту, мы можем создать процесс (сервис), который будет иметь исключительный доступ записи и чтения из этого файла, этот процесс будет однопоточным и поэтому никаких объектов синхронизации доступа нам не понадобится. Все остальные процессы будут отправлять сообщения данному сервису (например WM_COPYDATA в системе Windows) с просьбой записать что-то в файл. Наш сервис будет крутиться в бесконечном цикле и проверять новые сообщения и если они есть, то что-то выполнять.

Но я попробую дать представление озвученного концепт на другом примере разработки пакета очень простого асинхронного кеша, который я назвал asycache который можно будет использовать в наших Go программах. Сам пакет доступен по адресу https://github.com/katasonov/asycache 

Задача
======

Создать асинхронный cache - Go тип, смысл которого хранить данные различного типа по строковому ключу. С данным типом могут работать параллельно несколько goroutines. Методы Set и Get, добавляющие и возвращающие значения, должны быть неблокирующими. Таким образом для Get нужно указывать timeout после истечения которого метод возвращает управление. Для метода Set должна быть возможность либо вернуть управление моментально не дожидаясь окончания операции, либо дождаться окончания. Дополнительно требуется, чтобы для каждого хранимого элемента можно было задавать время жизни по истечению которого элемент удаляется из кеша.

В качестве хранилища данных нам подойдет стандартный map, который встроен в язык Go и позволяет хранить любые типы данных по строковому ключу.

Накидаем следующие типы

Для начала заведем тип ноды которая будет содержать основные данные помещенные в кеш и некоторую рабочую информацию. Эдакая обертка. Тип начинается с маленькой буквы для того, чтобы к нему не было доступа из вне нашего пакета (фича языка Go). В других языках для этого используется дополнительное ключевое слово типа private, но в Go выбрали путь минимализма.

---------------
type cacheEntity struct {
	//Объект добавленный в кеш по ключу
	//Тип interface{} указывает нам на то, что объект может
	//быть любым интерфейсным типом либо указателем.
	data interface{}
}

---------------

Теперь тип нашего кеша. Пока там будет только map для хранения объектов по строковому ключу. Обратите внимание, что словарь хранит не сами объекты, а указатели на них. Это будет полезно, т.к. мы сможем изменять элементы словаря прямо в нем без необходимости копировать их(entities[<ключ>].<поле> = <новое значение>). К тому жеэто может несколько ускорить операции вставки и получения элемента. Тип так же начинается с маленькой буквы, чтобы запретить его инстанциирование через оператор new, чтобы не дать возможность создавать не инициализированные копии. Для инстанциации создадим специальный фабричный метод.

---------------
//Тип нашего кеша, который хранить служебные данные
//для работы кеша.
type cache struct {
	//Хранилище наших объектов. Хранит указатели на cacheEntity
	//для того, чтобы ускорить доступ к объектам и упростить их
	//изменение.
	entities map[string]*cacheEntity
}

---------------

Вот теперь создадим сам фабричный метод.

---------------
//Функция возвращающая нам указатель на новый объект кеша
func MakeCache() *cache {
	//Инициализируем наш кеш
	//Конструкция &Type{} инициализирует нам объект и возвращает его указатель
	//Да, в Go можно безопасно вернуть указатель на локальный объект и
	//и далее его использовать :)
	c := &cache{entities: make(map[string]*cacheEntity)}

	return c
}

---------------
Обратите внимание на то, как инициализируется map. Для этого существует специальная встроенная функция make. В качестве параметра передаем её тип требуемой map и еще вторым аргументом опционально можно запросить требуемую capacity. 

И добавим пару функций для вставки и получения элементов кеша.

---------------

//Функция Set у типа cache (как метод класса в C++ или Java)
//которая вставляет новый элемент в кеш
//k - строковый параметр функции, являющийся ключем в кеше
//v - элемент любого типа либо указатель, который мы хотим положить в кеш
func (c *Cache) Set(k string, v interface{}) {
	//пока сделаем не thread safe реализацию и просто вставим элемент
	entities[k] = &cacheEntity{data: v}
}

func (c *Cache) Get(k string) (interface{}) {
	v, ok := entities[k]
	if !ok: {return nil}
	return v.data
}

---------------

Не thread safe прототип нашего кеша готов. Но поскольку с данным кешом могут работать несколько паралельных goroutines, мы должны как-то синхронизировать доступ к нашему map, т.к. map в Go по умолчанию не является атомарным(thread safe) ресурсом. Классический метод синхронизации доступа - повешать неблокирующий мьютекс на ресурс в методах Get и Set. Но это достаточно низкоуровневый подход, а мы хотим попробовать что-то новое и модное. Поэтому воспользуемся такими фичами языка Go как goroutines и channels.

Goroutines - можно понимать как легковесные потоки. Легковесные они потому, что не требуют существенного времени на свое создание и не занимают каких-то системных ресурсов, в отличии от потоков. Поэтому создавать мы можем их сотнями или даже тысячами и особо не париться по этому поводу.

Channels - можно понимать как легковесные сокеты или пайпы. Бывают односторонние или двусторонние. Тут нужно уточнить, одностороннесть канала (например только на чтение) обеспечивается за счет приведения его к соотвествующему типу при передаче какой-нибудь goroutine, но изначально они все работают на прием и на передачу. Опять же легковесность обеспечивается за счет того, что это не системный ресурс и не требует много времени на свое создание.

Так вот имея два таких инструмента в языке мы можем решить проблему синхронизации без мьютексов. А идея в том, что для каждого нашего объекта типа cache будет существовать выделенная обслуживающая goroutine, которая и будет иметь исключительный доступ к хранилищу данных (вспоминаем аналогию с однопоточным процессом). Все остальные параллельно работающие goroutine будут запрашивать обслуживающую goroutine(через каналы) добавить элемент либо выдать элемент по ключу. В дополнение она будет периодически проверять все ли элементы еще актуальны или какие-то можно выкинуть из хранилища. 

Для удобства заведем два новых типа данных для передачи по соотвествующим каналам:

---------------
// Пара значений для вставки k - ключ и v - значение
type setChanParam struct {
	k           string
	v           interface{}
}
//передаем ключ k элемента который хотим запросить и
//канал на котором будем будем ожидать результат
type getChanParam struct {
	k    string
	//канал только на запись для возврата запрошенного значения
	clbk chan<- interface{}
}

---------------

Каналы объявляются как: <name>  [<direction>] chan [<direction>] <transport type>
В getChanParam используем только канал на запись. Если же хотим объявить канал только на чтение, то делается это так <- chan interface{}.

Далее для реализации нашей идеи добавим пару соотвествующих каналов как поля в наш кеш


---------------
//Тип нашего кеша, который хранить служебные данные
//для работы кеша.
type cache struct {
	//Хранилище наших объектов. Хранит указатели на cacheEntity
	//для того, чтобы ускорить доступ к объектам и упростить их
	//изменение.
	entities map[string]*cacheEntity
	//Канал на запись нового значения (возвращает тип setChanParam)
	set_chan chan setChanParam
	//канал на чтение (возвращает тип getChanParam)
	get_chan chan getChanParam
}
---------------

Теперь необходимо добавить парочку каналов в тело фабричной функции MakeCache. Обратите внимание как создаются каналы. Их необходимо инстациировать и инициализировать с помощью ключевого слова make как и map. 
---------------
func MakeCache() *cache {
	//Добавим еще инициализацию парочки каналов
	//Каналы как и map инстанциируется с помощью make,
	//вторым опциональным аргументом для канала она принимает
	//размер буфера канала.
	c := &cache{entities: make(map[string]*cacheEntity),
				set_chan: make(chan setChanParam, 100),
				get_chan: make(chan getChanParam, 100)}

	return c
}
---------------

Надо упомянуть, что каналы бывают буферизированные и небуферезированные. Буферизированные каналы блокируют операцию чтения или записи до тех пор пока приемник и передатчик оба не будут готовы для передачи (вызовут соотвествующую операцию канала). Небуферизированные каналы позволяют передатчику, в случае если буфер не заполнен, просто записать значение в буфер и тут же вернуть управление, а приемнику, в случае если буфер не пуст, взять следующее значение в порядке очереди из буфера и вернуть управление. В нашем случае пусть размер будет 100.

Теперь королева бала - управляющая goroutine, которую мы запустим прямо в методе MakeCache используя механизм <ref>замыканий</ref> в Go.

---------------
func MakeCache() *cache {
	...

	//стартуем новую goroutine которая выполняет заданную функцию
	go func() {
		//запускаем бесконечный цикл, т.к. мы хотим теперь очень долго обслуживать клиентов
		//нашего кеша :)
		for {
			//оператор select по форме напоминает switch, по содержанию 
			//что-то типа POSIX-сного select только для каналов
			select {
			//в случае если <-c.get_chan готов, возвращаемое значение получаем в gcp
			case gcp := <-c.get_chan:
				v, ok := c.entities[gcp.k]
				if !ok {
					gcp.clbk <- nil
					break //выходим из select
				}
				gcp.clbk <- v.data
			//в случае если <-c.set_chan готов, возвращаемое значение получаем в scp
			case scp := <-c.set_chan:
				c.entities[scp.k] = &cacheEntity{data: scp.v}
			}
		}
	}()

	return c
}
---------------

Оператор select в методе работает примерно так: если не заданого default(как в switch) он блокируется до тех пор пока какой-нибудь из каналов не вернет значения. Если задан default, то он выбирается в случае если ни один из каналов не готов. Обратите внимание что в нашей goroutine мы используем объект c,
созданный в parent функции MakeCache через механизм замыканий.


Теперь изменим уже упомянутые методы Set и Get для асинхронной работы.

---------------
func (c *Cache) Set(k string, v interface{}) {
	//Записываем в соотвествующий канал полученные ключ и значение
	//и тутже возвращаем управление
	c.set_chan <- setChanParam{k, v}
	return
}

func (c *Cache) Get(k string) (interface{}) {
	//Создаем callback канал для последующего чтения значения
	clbk := make(chan interface{}, 1)
	//Записываем в соотвествующий канал кеша требуемый ключ и наш
	//свеже испеченный callback и сразу возвращаем управление
	c.get_chan <- getChanParam{k, clbk}
	//объявим переменную в которую получим значение
	var v interface{}
	v = nil //занулим пока-что
	//ожидаем ответа от кеша
	//мы блокируемся пока не считаем!
	v = <-clbk:
	return v
}
---------------

	//Так как select блокируется (без default) пока какой-нибудь
	//канал не будет готов, то бесконечного цикла нам не нужно!

И вот теперь вызов Set полностью неблокирующий, а Get блокируется и ожидает значение. И наш кеш полностью thread safe. Но это не совсем то, что требовалось. Мы то хотим, чтобы Get хотябы мог вернуть управление по таймауту, а после вызова Set мы могли бы по желанию как-то проверить, что значение успешно добавлено в кеш.

Давайте добавим таймаут в метод Get

---------------
//Duration это тип обозначающий промежуток времени в наносекундах
//и для него нам нужно сделать импорт пакета time(import . time)
//. при импорте пакета обозначает, что мы хотим добавить все имена
//из пакета time в нашу область видимости.
//timeout - сколько мы хотим ждать требуемое значения.
//еще в качестве возврата из функции добавим bool переменную обозначающую
//вернулись ли мы по таймауту или всетаки получили значение
func (c *cache) Get(k string, timeout Duration) (interface{}, bool) {
	...
	//создаем специальный объект из пакета time типа Ticker
	//который хранит канал C, в который пишут после заданного таймаута
	ticker := NewTicker(timeout)
	var v interface{}
	v = nil
	//Так как select блокируется (без default) пока какой-нибудь
	//канал не будет готов, то по сути мы блокируемся пока, не
	//получим значения из кеша либо пока не сработает наш таймер
	select {
	case v = <-clbk:
		if v != nil {
			return v, true
		}
		return nil, false
	//ожидаем так-же срабатывание тикера
	case <-ticker.C:
		return nil, false
	}
	return v, false
}
---------------

И вот сейчас метод Get работает как мы хотим. Блокируется до тех пор пока не вернется значение либо выходим по таймауту.

---------------
value = someCacheObject.Get("some key", 10*time.Second) //таймаут 10 секунд
---------------

Теперь давайте улучшим наш метод Set. Пусть он возвращает нам канал, который мы сможем слушать и в случае возврата понять записалось ли значение в кеш или нет.

---------------
//возвращаем канал на чтение, который можно слушать на предмет результата записи значения.
func (c *cache) Set(k string, v interface{}) <-chan bool {
	//создаем новый канал в который управляющая кешем goroutine будет писать результат
	//выделяем буфер размера 1, чтобы запись не блокировалась
	finish_chan := make(chan bool, 1)
	//запрашиваем запись
	c.set_chan <- setChanParam{k, v, finish_chan}
	//и тутже возвращаем канал из которого получим результат
	return finish_chan
}
---------------

Внесем также соотвествующие изменения в setChanParam

---------------
type setChanParam struct {
	k           string
	v           interface{}
}
---------------

и в управляющую goroutine.
---------------
func MakeCache() *cache {
	...

	go func() {
		for {
			select {
			...
			case scp := <-c.set_chan:
				//Проверим что ключ не пустой
				if len(scp.k) > 0 {
					c.entities[scp.k] = &cacheEntity{data: scp.v}
					scp.finish_chan <- true
				} else {
					scp.finish_chan <- false
				}
				//закрываем канал, т.к. он больше не нужен
				close(scp.finish_chan)
			}
		}
	}()

	return c
}
---------------

Теперь мы можем получить результат работы метода Set если захотим.

---------------
c := MakeCache()
//вызываем Set и сразу же читаем из канала результат (по сути блокируемся пока не вставит значение)
ok := <-c.Set("", "hello", 3*time.Second)
---------------

