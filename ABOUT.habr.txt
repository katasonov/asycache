Golang: Не взаимодействуй через общую память, обращайся к памяти через взаимодействие

Так я перевел высокоуровневую концепцию синхронизации доступа к общим ресурсам, представленную разработчиками языка Go "Do not communicate by sharing memory; instead, share memory by communicating".

Для наглядности можно представить себе это через следующую аналогию: представим что у нас есть дисковый файл, куда хотят писать сразу куча процессов. Для синхронизации доступа мы можем использовать системный мьютекс. Кто успел залокать, тот и пишет, все остальные ждут. Либо, обращаясь к представленному концепту, мы можем создать процесс (сервис), который будет иметь исключительный доступ записи и чтения из этого файла, этот процесс будет однопоточным и поэтому никаких объектов синхронизации доступа нам не понадобится. Все остальные процессы будут отправлять сообщения данному сервису (например WM_COPYDATA в системе Windows) с просьбой записать что-то в файл. Наш сервис будет крутиться в бесконечном цикле и проверять новые сообщения и если они есть, то что-то выполнять.

Но я попробую дать представление озвученного концепт на другом примере разработки пакета очень простого асинхронного кеша, который я назвал asycache который можно будет использовать в наших Go программах. 

Задача: Создать асинхронный cache - Go тип, смысл которого хранить данные различного типа по строковому ключу. С данным типом могут работать параллельно несколько goroutines. Методы Set и Get, добавляющие и возвращающие значения, должны быть неблокирующими. Таким образом для Get нужно указывать timeout после истечения которого метод возвращает управление. Для метода Set должна быть возможность либо вернуть управление моментально не дожидаясь окончания операции, либо дождаться окончания. Дополнительно требуется, чтобы для каждого хранимого элемента можно было задавать время жизни по истечению которого элемент удаляется из кеша.

В качестве хранилища данных нам подойдет стандартный map, который встроен в язык Go и позволяет хранить любые типы данных по строковому ключу.

Накидаем следующие типы

---------------
// Тип обертка над элементом хранящимся в нашем кеше. 
// Тип начинается с маленькой буквы для того, чтобы к нему
// не было доступа из вне нашего пакета (фича языка Go).
// Содержит сам объект хранения и служебную информацию
type cacheEntity struct {
	//Объект добавленный в кеш по ключу
	//Тип interface{} указывает нам на то, что объект может
	//быть любым интерфейсным типом либо указателем.
	data interface{}
}

//Тип нашего кеша, который хранить служебные данные
//для работы кеша.
type Cache struct {
	//Хранилище наших объектов. Хранит указатели на cacheEntity
	//для того, чтобы ускорить доступ к объектам и упростить их
	//изменение.
	entities map[string]*cacheEntity
}
---------------

Поскольку с данным кешом могут работать несколько паралельных goroutines, мы должны как-то синхронизировать доступ к нашему map, т.к. map в Go по умолчанию не является атомарным(thread safe) ресурсом. 

Классический метод синхронизации доступа - повешать мьютекс на ресурс. Но это достаточно низкоуровневый подход, а мы хотим попробовать что-то новое и модное. Поэтому воспользуемся такими фичами языка Go как goroutines и channels.

Goroutines - можно понимать как легковесные потоки. Легковесные они потому, что не требуют существенного времени на свое создание и не занимают каких-то системных ресурсов, в отличии от потоков. Поэтому создавать мы можем их сотнями или даже тысячами и особо не париться по этому поводу.

Channels - можно понимать как легковесные сокеты или пайпы. Пывают односторонние или двусторонние. Опять же легковесность обеспечивается за счет того, что это не системный ресурс и не требует много времени на свое создание.

Так вот имея два таких инструмента в языке мы можем решить проблему синхронизации без мьютексов. А идея в том, что для каждого нашего объекта типа Cache будет существовать выделенная обслуживающая goroutine, которая и будет иметь исключительный доступ к хранилищу данных. Все остальные параллельно работающие goroutine будут просить обслуживающую либо добавить элемент либо выдать элемент по ключу. А еще она будет периодически проверять все ли элементы еще актуальны или какие-то можно выкинуть из хранилища. Для наглядности можно провести аналогию с реальным выделенным на компьютере однопоточным cache сервером (процессом) доступ к которому осуществляется через сокеты, тоесть по скольку сервер однопоточный, то вся синхронизация осуществляется исключительно системой, например через вызов select.




